#!/usr/bin/env python3
# This file is placed in the Public Domain.


"objects"


import inspect
import os
import queue
import sys
import termios
import time
import threading
import _thread


sys.path.insert(0, os.getcwd())


from objx.default import Default
from objx.object  import Object
from objr.handler import Commands, Event, Handler
from objr.persist import Persist
from objr.thread  import launch
from objr.utils   import parse, spl


if os.path.exists("mods"):
    import mods as MODS
else:
    MODS = None


Cfg         = Default()
Cfg.debug   = True
Cfg.mod     = ""
Cfg.name    = "objx"
Cfg.silent  = False
Cfg.version = "83"
Cfg.wdr     = ".test"


class CLI(Handler):

    "CLI"


    def __init__(self):
        Handler.__init__(self)
        self.register("command", command)

    def say(self, _channel, txt):
        "echo on verbose."
        self.raw(txt)

    def raw(self, txt):
        "print to screen."
        txt = txt.encode('utf-8', 'replace').decode()
        print(txt)

    def show(self, evt):
        "show results into a channel."
        for txt in evt.result:
            self.say(evt.channel, txt)


class Console(CLI):

    "Console"

    def announce(self, txt):
        "disable announce."

    def callback(self, evt):
        "wait for callback."
        CLI.callback(self, evt)
        evt.wait()

    def poll(self):
        "poll console and create event."
        evt = Event()
        evt.orig = object.__repr__(self)
        evt.txt = input("> ")
        evt.type = "command"
        return evt


def cmnd(txt):
    "do a command using the provided output function."
    cli = CLI()
    evn = Event()
    evn.orig = repr(cli)
    evn.txt = txt
    command(cli, evn)
    evn.wait()
    return evn


def scan(pkg, modstr):
    "scan modules for commands and classes"
    mds = []
    for modname in spl(modstr):
        module = getattr(pkg, modname, None)
        if not module:
            continue
        Commands.scan(module)
    return mds


"callbacks"


def command(bot, evt):
    "check for and run a command."
    parse(evt)
    func = getattr(Commands.cmds, evt.cmd, None)
    if func:
        func(evt)
    bot.show(evt)
    evt.ready()


"commands"


def cmd(event):
    "list commands."
    event.reply(",".join(sorted(list(Commands.cmds))))


"runtime"


def wrap(func):
    "reset terminal."
    old2 = None
    try:
        old2 = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        func()
    except (KeyboardInterrupt, EOFError):
        print("")
    finally:
        if old2:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old2)


def main():
    "main"
    Persist.workdir = Cfg.wdr
    Commands.add(cmd)
    Cfg.mod = ",".join(dir(MODS))
    parse(Cfg, " ".join(sys.argv[1:]))
    if "v" in Cfg.opts:
        dte = " ".join(time.ctime(time.time()).replace("  ", " ").split()[1:])
        print(f'{dte} {Cfg.name.upper()} {Cfg.opts.upper()} {Cfg.mod.upper()}'.replace("  ", " "))
    scan(MODS, Cfg.mod)
    if "c" in Cfg.opts:
        csl = Console()
        csl.start()
        while 1:
            time.sleep(1.0)
    elif Cfg.otxt:
        cmnd(Cfg.otxt)


if __name__ == "__main__":
    wrap(main)
